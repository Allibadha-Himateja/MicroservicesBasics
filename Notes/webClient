 The webclient is a better approach for communication between services

 // as we already know the restTemplate is for synchronous communication which leads to blocking the main thread
 // inside the synchronous rest controller which will potentially lead to the slow performance for the api

 // the solution for the limitations for restTemplate we have webClient

 WebClient is a non-blocking, reactive web client introduced as part of the Spring WebFlux framework.
 It is built to support asynchronous and streaming scenarios,
 making it ideal for applications requiring high concurrency and scalability.

 1. Reactive and Non-Blocking Applications
  WebClient is the go-to choice when developing reactive applications.
  Reactive programming is designed to handle a large number of concurrent requests efficiently by leveraging non-blocking I/O.
  Use WebClient in the following cases:

    Reactive APIs: If your application uses Reactor, RxJava, or other reactive frameworks, WebClient integrates seamlessly.
    Event-Driven Architectures: Systems that rely on events, such as IoT platforms, benefit from the asynchronous capabilities of WebClient.

 FIRST
 //dependency
 <dependency>
     <groupId>org.springframework</groupId>
     <artifactId>spring-webflux</artifactId>
     <version>7.0.2</version>
 </dependency>

 SECOND
 // the application of this webClient can be used for both the synchronous and asynchronous programming
 // the step after configuring the dependency we have to create the Bean for the webClient in order to use that

    public WebClient.Builder webClient() {
        return WebClient.builder().baseUrl("http://localhost:8081/marks");
    }

 THIRD
 // the use of this webclient bean is directly inside the @Service which is StudentService
 // calling the MarksAPI from the StudentAPI via webclient will be
    Mono<ResponseEntity<List<Marks>>> marks=webClient.build().get().uri("/list")
                    .retrieve()
                    .toEntity(new ParameterizedTypeReference<List<Marks>>() {});

            marks.subscribe(p->p.getBody().stream().forEach(System.out::println));

 FOURTH
 // we have to use the webClient.build().get().uri().retrieve()
 // and for the type exchange we can use the .toEntity() method .bodyToMono() or bodyToFlux()
 Mono<ResponseEntity<Person>> result = client.get()
 		.uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
 		.retrieve()
 		.toEntity(Person.class);
 Mono<Person> result = client.get()
 		.uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
 		.retrieve()
 		.bodyToMono(Person.class);
 To get a stream of decoded objects:
 Flux<Quote> result = client.get()
 		.uri("/quotes").accept(MediaType.TEXT_EVENT_STREAM)
 		.retrieve()
 		.bodyToFlux(Quote.class);

 /// UNDERSTANDING HOW THE WEBCLIENT IS ASYNCHRONOUS
 // for the comparison of webClient with the restTemplate
 // the restTemplate will be a One thread per Request manner
 // whereas the webclient is all about EVENTLOOP

 // NOTE: .block()
 If you call .block() on a WebClient call, you are destroying its asynchronous nature.
 You are forcing the thread to wait, effectively turning it back into a RestTemplate.
 To get the true benefit, you should return the Mono or Flux all the way to your controller.